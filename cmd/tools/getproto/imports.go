package main

import (
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"golang.org/x/exp/maps"
)

var (
	matchImport   = regexp.MustCompile(`^\s*import\s+"([^"]+\.proto)"\s*;\s*$`)
	versionSuffix = regexp.MustCompile(`^(.*)/v\d+$`)
)

func getImportName(i string) string {
	withoutV := i
	if match := versionSuffix.FindStringSubmatch(i); match != nil {
		withoutV = match[1]
	}
	return filepath.Base(withoutV)
}

func mangle(p string) string {
	mangled := strings.ReplaceAll(p, "/", "_")
	return "File_" + strings.ReplaceAll(mangled, ".", "_")
}

func genFileList(protoImports []string) {
	goImportsMap := make(map[string]string)
	protoToPackage := make(map[string]string)

	for _, i := range protoImports {
		if strings.HasPrefix(i, "temporal/api/") {
			goImport := filepath.Dir(strings.Replace(i, "temporal/api/", "go.temporal.io/api/", 1))
			// FIXME: make unique import name
			importName := getImportName(goImport)
			goImportsMap[goImport] = importName
			protoToPackage[i] = importName
		} else if strings.HasPrefix(i, "proto/internal/temporal/") {
			goImport := filepath.Dir(strings.Replace(i, "proto/internal/temporal/", "go.temporal.io/", 1))
			// FIXME: make unique import name
			importName := getImportName(goImport)
			goImportsMap[goImport] = importName
			protoToPackage[i] = importName
		} else if strings.HasPrefix(i, "google/") {
			// FIXME: handle annotations again
			base := strings.TrimSuffix(filepath.Base(i), ".proto") + "pb"
			goImport := "google.golang.org/protobuf/types/known/" + base
			goImportsMap[goImport] = base
			protoToPackage[i] = base
		}
	}
	goImports := maps.Keys(goImportsMap)
	sort.Strings(goImports)

	out, err := os.Create("cmd/tools/getproto/files.go")
	fatalIfErr(err)
	defer out.Close()
	out.WriteString("// Code generated by getprotogen/generate.go. DO NOT EDIT.\n\n")
	out.WriteString("package main\n\n")
	out.WriteString("import (\n")
	fmt.Fprintf(out, "\t%q\n\n", "google.golang.org/protobuf/reflect/protoreflect")
	for _, i := range goImports {
		fmt.Fprintf(out, "\t%s %q\n", goImportsMap[i], i)
	}
	out.WriteString(")\n\n")
	out.WriteString("func forEachFile(f func(string, protoreflect.FileDescriptor)) {\n")
	for _, i := range protoImports {
		if !strings.HasPrefix(i, "proto/internal/temporal") {
			fmt.Fprintf(out, "\tf(%q, %s.%s)\n", i, protoToPackage[i], mangle(i))
		}
	}
	out.WriteString("}\n\n")
	out.WriteString("func forEachInternalFile(f func(string, protoreflect.FileDescriptor)) {\n")
	for _, i := range protoImports {
		if strings.HasPrefix(i, "proto/internal/temporal") {
			withoutProtoInternal := strings.TrimPrefix(i, "proto/internal/")
			fmt.Fprintf(out, "\tf(%q, %s.%s)\n", i, protoToPackage[i], mangle(withoutProtoInternal))
		}
	}
	out.WriteString("}\n")
}

func addImports(missing []string) {
	have, err := os.ReadFile("cmd/tools/getproto/protofiles.txt")
	fatalIfErr(err)

	fileMap := make(map[string]struct{})
	for _, i := range strings.Split(string(have), "\n") {
		if i = strings.TrimSpace(i); len(i) > 0 {
			fileMap[i] = struct{}{}
		}
	}
	for _, i := range missing {
		fileMap[i] = struct{}{}
	}

	files := maps.Keys(fileMap)
	sort.Strings(files)
	data := []byte(strings.Join(files, "\n") + "\n")

	err = os.WriteFile("cmd/tools/getproto/protofiles.txt", data, 0644)
	fatalIfErr(err)

	genFileList(files)

	fmt.Println("<rerun>")
	os.Exit(0)
}

func initSeeds() {
	var files []string
	fatalIfErr(filepath.WalkDir("proto/internal/temporal", func(path string, d fs.DirEntry, err error) error {
		if d.Type().IsRegular() && strings.HasSuffix(path, ".proto") {
			files = append(files, path)
		}
		return nil
	}))
	sort.Strings(files)

	data := []byte(strings.Join(files, "\n") + "\n")
	err := os.WriteFile("cmd/tools/getproto/protofiles.txt", data, 0644)
	fatalIfErr(err)

	genFileList(files)

	fmt.Println("<rerun>")
	os.Exit(0)
}
